RDB에서 사용하는 3가지 인덱스 구조
- B-tree 인덱스
- 비트맵 인덱스
- 해시 인덱스


### B-tree 인덱스
가장 많이 사용되는 트리구조의 인덱스

검색성능이 조금더 뛰어난 B+tree인덱스도 존재하는데 
이는 B-tree에 비해 루트와 잎과의 거리를 가능한 일정하게 유지하려고 하기때문이다.

### 비트맵 인덱스
데이터를 비트 플래그로 변환해서 저장하는 형태(?)
카디널리티가 낮은 필드에대해서 효과가있다
갱신할때 오버헤드가 너무 크기때문에 빈번한 갱신이 일어나지않는 BI/DWH 용도로 사용된다

### 해시 인덱스
키를 해시분산해서 등가검색을 고속으로 실행하고자 만들어진 인덱스
등가검색 외에는 쓸모가없고, 지원도 거의하지않음 


B+tree 는 검색속도의 불균형이 거의없어서 데이터양이 증가해도 검색속도가 악화하는일이 없으며, 등호,부등호 를 사용한 검색조건에도 사용할수있다.


### 카디널리티와 선택률

![](https://velog.velcdn.com/images/dudwls0505/post/9f369ea1-2a8d-4d66-8d6e-0033771385dd/image.png)

카디널리티가 높다.
id>name>location 

클러스터링 팩터
=> 저장소에 같은값이 뭉쳐있음을 확인하는 지표(인덱스의 성능을 결정한다)
지표가 높을수록 분산되어있고, 낮을수록 뭉쳐있다.

> 인덱스를 사용하기 좋은 상황은 카디널리티가 높고, 선택률이 낮은것(한번의 선택으로 선택되는 레코드수가 적은상황)이다.


### 인덱스로 성능 향상이 어려운경우

- 압축조건이 존재하지않음
```sql
SELECT order_id, receive_date
FROM Orders;
```
극단적인경우 , 인덱스로 작성할 껀덕지가없다

- 레코드를 제대로 압축하지 못하는경우
```sql
SELECT order_id, receive_date
FROM Orders
WHERE process_flg ='5';
```
위의 상황보단 자주일어나고 번거로운경우
-> 압축조건은 있지만 레코드를 제대로 압축하지못한다

process_flg='5' 로 선택된 레코드수의 선택률이 엄청나게 높다면, 풀스캔보다 느려질 가능성이 생긴다.



- 입력 매개변수에 따라 선택률이 변동하는경우
```sql
SELECT order_id
FROM Orders
WHERE receive_date BETWEEN :start_date AND :end_date;
```
외부에서 받는 매개변수의 값에 따라서 선택되는 레코드수가 달라지며 선택률이 달라지는경우이다. 이경우에는 입력되는 매개변수에 따라 선택률이 좌우된다.

```sql
SELECT COUNT(*)
FROM Orders
WHERE shop_id = :sid;
```
주어지는 sid매개변수의 값에 따라 선택률이 달라지며, 인덱스보다 풀스캔이 나을상황도있을것이고 반대의상황도 있을것이다.

- 인덱스를 사용하지 않는 검색조건
```sql
SELECT order_id
FROM Orders
WHERE shop_name LIKE '%대공원%';
```
LIKE연산자를 사용하는경우 인덱스는 전방일치(대공원%) 에만 적용할수있다.
이외에 색인필드,IS NULL, 부정형(<>,!=,NOT IN)을 사용하는경우 인덱스를 사용할수없다.

### 인덱스를 사용할수없는경우 대처법

**1.애플리케이션에서의 설정으로 처리하는방법**

웹입력화면에서 UI설계로 입력제한을 둔다던지, ID를검색하면 주문일도 함께 입력해야 검색을 할수있다던지 등 혹은 기간검색을 최대 1개월까지 설정한다던지  설계를 해두면
인덱스를 잘 사용할 가능성이 커진다.
=> 어떤 ui를 준비하고 , 어떤 제한을 만들지는 사용자 혹은 엔지니어와 상의해본다

**주의점**
프로젝트를 시작하는단계에서부터 합의해야하고, 테스트단계에서 성능문제가 발견된다면 오히려 안좋은상황이 닥친다. 

**1-2. 데이터 마트로 대처**
접근 대상 테이블의 크기를 작게해서 I/O 양을 줄이는것이 목적
원래테이블에서 쿼리에 필요한 필드값들만 따로 빼서 데이터마트를 만드는것 

**주의점**
- 원본 테이블에서 복사를 해와야하므로 빈번한 갱신이 필요하다. 이는 성능적으로 문제가될수있고 갱신이 줄어든다면 데이터의 신선도가 줄어든다.
- 테이블을 줄일수 없다면 데이터마트를 만들어도 빨라지지않음
- 데이터마트 수가 많아지게되면 관리하기 힘들어질수있다. 
- 일정규모 이상의 갱신이 발생할때마다 처리를 여유롭게 수행하기위한 배치윈도우를 고려해야한다


2.인덱스 온리 스캔으로 대처
SQL구문이 접근하려는 대상의 I/O감소를 목적으로 한다. 
```sql
SELECT order_id, receive_date
FROM Orders;
```
풀스캔이 발생했었던 쿼리문에서 검사대상을 테이블이아닌 인덱스로 변경할수있다.
```sql
CREATE INDEX CoveringIndex ON Orders (order_id, receive_date);
```
커버인덱스가 존재하면 테이블이아닌 인덱스만을 스캔대상으로 사용할수있게되어 테이블접근을 생략할수있다.
I/O비용을 줄일수있게되며 데이터 마트와는달리 애플리케이션을 수정할 필요가 없다.

인덱스가 존재하므로 테이블에 접근을하지않는다(옵티마이저의 자동판단)

```sql
//before
SELECT order_id, receive_date
FROM Orders
WHERE process_flg ='5';
//after
CREATE INDEX CoveringIndex_1 ON Orders(process_flg, order_id, receive_date);
```

```sql
//before
SELECT order_id
FROM Orders
WHERE shop_name LIKE '%대공원%';
//after
CREATE INDEX CoveringIndex_2 ON Orders (shop_name, order_id, receive_date);
```
이처럼 인덱스 온리스캔은 특정상황에서 검색성능을 극단적으로 높일수있는 강력한 기능이다. 

### 인덱스 온리스캔 주의사항
- DBMS에 따라 사용할수없는 경우도 있다. (이젠 거의없는듯)
- 인덱스의 크기도 제한이있다. 
- 검색성능은 향상하는대신 갱신 성능이 떨어지는 트레이드오프가 발생한다.
- 정기적인 인덱스 리빌드가 필요하다
- SQL 구문에 새로운필드가 추가된다면 사용할수없다


